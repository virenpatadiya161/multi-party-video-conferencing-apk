Here is a proof-of-concept for a multi-party video conferencing application using Vanilla JavaScript and Supabase for signaling. This application will allow up to 5 participants to join a meeting.

### How it Works

This application uses a **mesh network topology**, where each participant establishes a direct WebRTC connection with every other participant in the room. For a small number of users (3-5), this is a simple and effective approach.

**Signaling**, the process of exchanging connection metadata (like SDP and ICE candidates) to set up the peer-to-peer connections, is handled by **Supabase's Realtime Database**. Instead of a traditional WebSocket server, we will use a Supabase table to broadcast and listen for signaling messages.

### Project Structure

You will need to create three files:

1.  `index.html`: The main HTML file for the user interface.
2.  `style.css`: For basic styling of the video elements.
3.  `app.js`: The core Vanilla JavaScript logic for WebRTC and Supabase integration.

---

### Step 1: Set up Supabase

1.  **Create a Supabase Project:**
    *   Go to [Supabase](https://supabase.com/) and create a new project.
    *   Once your project is created, navigate to the **SQL Editor**.

2.  **Create a Signaling Table:**
    *   In the SQL Editor, run the following query to create a table to handle signaling messages.

    ```sql
    CREATE TABLE signaling (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      room TEXT NOT NULL,
      sender_id TEXT NOT NULL,
      recipient_id TEXT,
      payload JSONB NOT NULL,
      created_at TIMESTAMPTZ DEFAULT NOW()
    );

    -- Enable Realtime on the table
    ALTER PUBLICATION supabase_realtime ADD TABLE signaling;

    -- Add Row Level Security (RLS)
    ALTER TABLE signaling ENABLE ROW LEVEL SECURITY;

    -- Create policies to allow clients to read and write to the table
    CREATE POLICY "Allow all access" ON signaling
    FOR ALL
    USING (true)
    WITH CHECK (true);
    ```

3.  **Get Your Supabase Credentials:**
    *   Go to **Project Settings** > **API**.
    *   Find your **Project URL** and the `anon` **public** key. You will need these for your `app.js` file.

---

### Step 2: Create the Application Files

#### `index.html`

This file contains the basic structure of the application, including video elements and a form to join a room.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Meeting</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>WebRTC Multi-Party Meeting</h1>

    <div id="join-area">
        <input type="text" id="room-id" placeholder="Enter Room Name">
        <button id="join-button">Join Room</button>
    </div>

    <div id="video-container" class="hidden">
        <div class="video-wrapper">
            <h3>You</h3>
            <video id="local-video" autoplay muted playsinline></video>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="app.js"></script>
</body>
</html>
```

#### `style.css`

This file provides some basic styling for the video grid.

```css
body {
    font-family: sans-serif;
    background-color: #f0f0f0;
    margin: 0;
    padding: 20px;
    text-align: center;
}

#join-area {
    margin-bottom: 20px;
}

#room-id {
    padding: 10px;
    font-size: 16px;
}

#join-button {
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
}

#video-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
}

.video-wrapper {
    border: 2px solid #ccc;
    border-radius: 8px;
    background-color: #fff;
    padding: 10px;
}

video {
    width: 320px;
    height: 240px;
    background-color: #000;
    border-radius: 5px;
}

.hidden {
    display: none;
}
```

#### `app.js`

This is the core of the application. **Remember to replace `'YOUR_SUPABASE_URL'` and `'YOUR_SUPABASE_ANON_KEY'` with your actual Supabase credentials.**

```javascript
/**
 * @typedef {import('@supabase/supabase-js').SupabaseClient} SupabaseClient
 * @typedef {import('@supabase/supabase-js').RealtimeChannel} RealtimeChannel
 */

const SUPABASE_URL = 'YOUR_SUPABASE_URL';
const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';

const joinArea = document.getElementById('join-area');
const roomIdInput = document.getElementById('room-id');
const joinButton = document.getElementById('join-button');
const videoContainer = document.getElementById('video-container');
const localVideo = document.getElementById('local-video');

/** @type {SupabaseClient} */
let supabase;
/** @type {RealtimeChannel} */
let realtimeChannel;
/** @type {string | null} */
let myId = null;
/** @type {string | null} */
let currentRoom = null;
/** @type {MediaStream | null} */
let localStream = null;

/** @type {Object<string, RTCPeerConnection>} */
const peerConnections = {};

const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
    ],
};

joinButton.addEventListener('click', async () => {
    const room = roomIdInput.value.trim();
    if (room) {
        currentRoom = room;
        joinArea.classList.add('hidden');
        videoContainer.classList.remove('hidden');
        await init();
    }
});

async function init() {
    myId = `user-${Math.random().toString(36).substring(2, 9)}`;
    console.log('My ID:', myId);

    supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;

    setupSignaling();
}

function setupSignaling() {
    realtimeChannel = supabase.channel(`room:${currentRoom}`, {
        config: {
            broadcast: {
                self: false,
            },
        },
    });

    realtimeChannel
        .on('broadcast', { event: 'join' }, ({ payload }) => {
            console.log(`${payload.sender_id} joined the room`);
            createPeerConnection(payload.sender_id, true);
        })
        .on('broadcast', { event: 'signal' }, ({ payload }) => {
            const { sender_id, recipient_id, data } = payload;
            if (recipient_id === myId) {
                handleSignal(sender_id, data);
            }
        })
        .subscribe((status) => {
            if (status === 'SUBSCRIBED') {
                console.log('Subscribed to room:', currentRoom);
                realtimeChannel.send({
                    type: 'broadcast',
                    event: 'join',
                    payload: { sender_id: myId },
                });
            }
        });
}

/**
 * @param {string} peerId
 * @param {boolean} isInitiator
 */
function createPeerConnection(peerId, isInitiator) {
    if (peerConnections[peerId]) {
        console.log('Connection with', peerId, 'already exists.');
        return;
    }
    console.log('Creating peer connection with', peerId);

    const pc = new RTCPeerConnection(iceServers);
    peerConnections[peerId] = pc;

    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    pc.onicecandidate = (event) => {
        if (event.candidate) {
            sendSignal(peerId, { candidate: event.candidate });
        }
    };

    pc.ontrack = (event) => {
        addRemoteStream(peerId, event.streams[0]);
    };

    pc.oniceconnectionstatechange = () => {
        if (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed' || pc.iceConnectionState === 'failed') {
            console.log('Peer', peerId, 'disconnected.');
            removePeer(peerId);
        }
    };

    if (isInitiator) {
        pc.createOffer()
            .then(offer => pc.setLocalDescription(offer))
            .then(() => {
                sendSignal(peerId, { sdp: pc.localDescription });
            })
            .catch(e => console.error('Error creating offer:', e));
    }
}

/**
 * @param {string} peerId
 * @param {any} data
 */
async function handleSignal(peerId, data) {
    const pc = peerConnections[peerId] || createPeerConnection(peerId, false);

    if (data.sdp) {
        try {
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            if (data.sdp.type === 'offer') {
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                sendSignal(peerId, { sdp: pc.localDescription });
            }
        } catch (e) {
            console.error('Error handling SDP:', e);
        }
    } else if (data.candidate) {
        try {
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (e) {
            console.error('Error adding ICE candidate:', e);
        }
    }
}

/**
 * @param {string} recipientId
 * @param {any} data
 */
function sendSignal(recipientId, data) {
    realtimeChannel.send({
        type: 'broadcast',
        event: 'signal',
        payload: {
            sender_id: myId,
            recipient_id: recipientId,
            data: data,
        },
    });
}

/**
 * @param {string} peerId
 * @param {MediaStream} stream
 */
function addRemoteStream(peerId, stream) {
    if (document.getElementById(`video-${peerId}`)) return; // Already exists

    const videoWrapper = document.createElement('div');
    videoWrapper.id = `wrapper-${peerId}`;
    videoWrapper.className = 'video-wrapper';

    const nameTag = document.createElement('h3');
    nameTag.innerText = `User: ${peerId.substring(5, 9)}`;

    const remoteVideo = document.createElement('video');
    remoteVideo.id = `video-${peerId}`;
    remoteVideo.srcObject = stream;
    remoteVideo.autoplay = true;
    remoteVideo.playsInline = true;

    videoWrapper.appendChild(nameTag);
    videoWrapper.appendChild(remoteVideo);
    videoContainer.appendChild(videoWrapper);
}

/**
 * @param {string} peerId
 */
function removePeer(peerId) {
    if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
    }
    const videoWrapper = document.getElementById(`wrapper-${peerId}`);
    if (videoWrapper) {
        videoWrapper.remove();
    }
}

window.addEventListener('beforeunload', () => {
    if (realtimeChannel) {
        realtimeChannel.unsubscribe();
    }
    Object.values(peerConnections).forEach(pc => pc.close());
});
```

---

### Step 3: Deploy and Run the Application

1.  **Deployment:** You can deploy these three files (`index.html`, `style.css`, `app.js`) to any static web hosting service like Netlify, Vercel, or GitHub Pages.

2.  **Running the App:**
    *   Open the deployed application in a browser.
    *   Enter a room name and click "Join Room".
    *   Open the same URL in another browser tab or on another device, enter the *same* room name, and join.
    *   The two participants should now see each other's video streams. You can repeat this for up to 5 participants.

### Important Considerations for this POC

*   **Security:** The Supabase RLS (Row Level Security) policies are set to `true` for simplicity. In a production environment, you would want to implement stricter rules to control who can read and write to the signaling table.
*   **Scalability:** A mesh network's bandwidth and CPU usage increase with each new participant. While it works well for a small group (3-5 users), it does not scale to a large number of participants. For larger meetings, you would need to use a more advanced architecture like a Selective Forwarding Unit (SFU).
*   **ICE Servers:** This example uses public STUN servers from Google to help establish connections between peers that are behind NATs. For a more reliable production application, you would also include TURN servers to relay traffic when a direct connection cannot be established.
*   **User Experience:** This is a barebones implementation. A production app would include features like mute/unmute, camera on/off, screen sharing, and better handling of users joining and leaving.